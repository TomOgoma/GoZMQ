package main

import (
	"bufio"
	"encoding/json"
	"errors"
	"fmt"
	zmq "github.com/pebbe/zmq4"
	"io"
	"io/ioutil"
	"log"
	"os"
)

type Service struct {
	SID, Name, Address, Reply string
}

var services = make(map[string]Service)
var allowedbinders, servicesFileName string
var mydescription Service
var myservices = make(map[string]string)

func init() {
	mydescription = Service{"lookup", "LooKUp Service", "tcp://localhost:5569", "lookup"}
	myservices["getservicedesc"] = "getservicedesc"
	myservices["register"] = "register"
	services["lookup"] = mydescription
	allowedbinders = "tcp://*:5569"
	servicesFileName = "dservices.json"

	//  Load Service List
	getServiceList()

	//  List available services
	listServices()
}

func main() {
	//  Socket to talk to clients
	responder, err := zmq.NewSocket(zmq.REP)
	if err != nil {
		panic(err)
	}
	defer responder.Close()
	responder.Bind(allowedbinders)
	fmt.Println("Directory Service at ", services["lookup"].Address, " waiting for connection...")

	//  Wait for next request from client
	for {
		//  Loop within a message envelope from a single client
		fmt.Println("\nWaiting for next client...\n")
		var serviceRequired string
		for count := 0; ; count++ {
			var request string
			var header []string
			header = append(header, mydescription.Reply)
			request, err := responder.Recv(0)
			fmt.Println("\tCurrent: ", request)
			if err != nil {
				log.Println(err)
				sendToClient("ErrorReceiving", header, "Error Retrieving message", 0, responder)
				break
			}
			//  All messages where count is even in the envelope are
			//  the expected service signature hence if the service is not
			//  Present return an error
			if count%2 == 0 {
				var isPresent bool
				serviceRequired, isPresent = myservices[request]
				if !isPresent {
					fmt.Printf("\nReceived request: %s\n", request)
					sendToClient("InvalidRequest", header, "Invalid Service Request", 0, responder)
					break
				}
				continue
			}
			//  Check if there are more in envelope otherwise break from loop
			if more, err := responder.GetRcvmore(); more {
				if err != nil {
					log.Println(err)
					continue
				}
				var reply string
				reply, err = processRequest(serviceRequired, request)
				if err != nil {
					log.Println(err)
				}
				header = append(header, reply)
			} else {
				if err != nil {
					break
				}
				var reply string
				success := "success"
				reply, err = processRequest(serviceRequired, request)
				if err != nil {
					success = fmt.Sprintf("%s", err)
				}
				sendToClient(reply, header, success, 0, responder)
				fmt.Println("\tDone")
				break
			}
		}
	}
}

func processRequest(serviceRequired, message string) (reply string, err error) {
	//  Request to register a service
	log.Println(serviceRequired)
	if serviceRequired == "register" {
		//  Valid (Register Service) request
		err = registerService(message)
		if err != nil {
			reply = fmt.Sprintf("%s", err)
			return
		}
		reply = "RegistrationSuccess"
		return
	} else if serviceRequired == "getservicedesc" {
		//  Valid (Get Service Description) request
		service, isPresent := services[message]
		//  Service not available
		if !isPresent {
			err = errors.New("NotAvailable")
			reply = "NotAvailable"
			return
		}
		//  Service located
		reply = string(encodeTOJSON(service))
		return
	} else {
		err = errors.New("InternalError")
		reply = "InternalError"
		return
	}
}

// Populates the services map with mappings for available
// services - services is a global variable hence no need
// for return
func getServiceList() {

	//read service list from file
	filepointer, err := os.Open(servicesFileName)
	if err != nil {
		log.Println(err)
		return
	}

	defer filepointer.Close()
	reader := bufio.NewReader(filepointer)
	line, err := reader.ReadBytes('\n')
	var service Service
	for err == nil {
		///*Decode from JSON
		err = json.Unmarshal(line, &service)
		if err != nil {
			log.Println("Error decoding from json")
			continue
		}
		services[service.SID] = service
		//read next line
		line, err = reader.ReadBytes('\n')
	}
	if err != io.EOF {
		log.Println(err)
	}
}

// Lists all available services in the service list including the
// "register" service that is not in the service list
func listServices() {
	fmt.Println("\n\n=====================\nAvailable services:\nSID\t\tName\t\t\tAddress")
	for _, service := range services {
		fmt.Println(service.SID, "\t\t", service.Name, "\t", service.Address)
	}
	fmt.Println("=====================\n")
}

//  Registers a new service by:
//  1. Decoding the JSON "register" message
//  2. Adding the decoded service to the service list
//  3. Encoding Entire service list to JSON and saving to file
func registerService(message string) (err error) {
	var newservice Service
	if len(services) == 0 {
		services = make(map[string]Service)
	}
	fmt.Println("\n\tProcessing Service Registration Request for ", message, " ...")
	//Decode Message
	fmt.Println("\tDecoding...")
	err = json.Unmarshal([]byte(message), &newservice)
	if err != nil {
		log.Println("Error decoding from JSON ", err)
		err = errors.New(fmt.Sprintf("DecodeFail:%s", err))
		return
	}

	fmt.Println("\tRegistering...")
	//Add to the active service list
	services[newservice.SID] = newservice

	fmt.Println("\tUpdating file...")
	//Encode entire service list to JSON
	var datab, b []byte
	for _, value := range services {
		b, err = json.Marshal(value)
		if err != nil {
			log.Println("Error encoding ", value.SID, " to JSON")
			err = errors.New(fmt.Sprintf("WriteFileFail:EncodeFail:%s", err))
			return
		}
		datab = append(datab, append(b, byte('\n'))...)
	}

	//write to file
	err = ioutil.WriteFile(servicesFileName, datab, os.ModePerm)
	if err != nil {
		log.Println("Error writing service list to file: ", err)
		err = errors.New(fmt.Sprintf("WriteFileFail:%s", err))
		return
	}

	//  Updated service list
	listServices()
	return
}

func sendToClient(message string, header []string, title string, more zmq.Flag, frontend *zmq.Socket) {

	fmt.Println("\t", title)
	for key := range header {
		fmt.Printf("\tSending header to client: %s\n", header[key])
		frontend.Send(header[key], zmq.SNDMORE)
	}
	fmt.Printf("\tSending message to client: %s\n", message)
	frontend.Send(message, more)
}

//  Encode service struct to json
func encodeTOJSON(service Service) []byte {
	//Encode to JSON
	b, err := json.Marshal(service)
	if err != nil {
		log.Println("Error encoding ", service.SID, " to JSON")
		panic(err)
	}
	return b
}
